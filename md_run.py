# -*- coding: utf-8 -*-
"""MD_RUN.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1WPlqZtL50tT4bKMiNtwyezDADvMzbZ03
"""

import pandas as pd
import numpy as np
import os
import matplotlib.pyplot as plt
import itertools
import argparse
import os
import sys
from pathlib import Path
import re
import glob

def stop_finder(df):
  stop_potential = []
  stop_start = []
  stop_end = []
  last_max = 0
  rc = len(df)
  for index, row in df.iterrows():
    #first we check if the maximum velocity of the row is less than our threshold of moving
    #if it is below we add the frame if to the list
    row_l = [abs(row['Velocity_X']), abs(row['Velocity_Y'])]
    if max(row_l) <= flux_threshold and sum(row_l) < 2*flux_threshold:
      stop_potential.append(row['FRAME_ID'])
      if index+1 == rc:
        if len(stop_potential) > len_stop_threshold:
          stop_start.append(stop_potential[0])
          stop_end.append(stop_potential[-1])
          stop_potential.clear()
          #last_max = 0
    else:
      if last_max <= flux_threshold and sum(row_l) < 2*flux_threshold:
        last_max = max(row_l)
        continue
      last_max = 2*flux_threshold
      if len(stop_potential) > len_stop_threshold:
        stop_start.append(stop_potential[0])
        stop_end.append(stop_potential[-1])
      stop_potential.clear()
  return([i for i in zip(stop_start, stop_end)])

def does_exist(id_to_check, df):
  if id_to_check in list(df['FRAME_ID']):
    return(True)
  else:
    return(False)

def increment_path(path, exist_ok=False, sep='', mkdir=False):
    # Increment file or directory path, i.e. runs/exp --> runs/exp{sep}2, runs/exp{sep}3, ... etc.
    path = Path(path)  # os-agnostic
    if path.exists() and not exist_ok:
        path, suffix = (path.with_suffix(''), path.suffix) if path.is_file() else (path, '')
        dirs = glob.glob(f"{path}{sep}*")  # similar paths
        matches = [re.search(rf"%s{sep}(\d+)" % path.stem, d) for d in dirs]
        i = [int(m.groups()[0]) for m in matches if m]  # indices
        n = max(i) + 1 if i else 2  # increment number
        path = Path(f"{path}{sep}{n}{suffix}")  # increment path
    if mkdir:
        path.mkdir(parents=True, exist_ok=True)  # make directory
    return path

FILE = Path(__file__).resolve()
ROOT = FILE.parents[0]  # YOLOv5 root directory
if str(ROOT) not in sys.path:
    sys.path.append(str(ROOT))  # add ROOT to PATH
ROOT = Path(os.path.relpath(ROOT, Path.cwd()))  # relative

parser = argparse.ArgumentParser(description='Add files')

parser.add_argument('--trash_file', type=str,   help='trash file as string')
parser.add_argument('--people_file', type=str,  help='people and car file as string')
parser.add_argument('--save_path', type=str,  default=ROOT / 'dumping', help='path the file is saved in')

args = parser.parse_args()

data_columns = ['FRAME_ID', 'ID', 'BOX_LEFT',  'BOX_TOP', 'BOX_W', 'BOX_H', 'class', 'class_txt']

pc_data = pd.read_csv(args.people_file, sep = ' ', header = None, names = data_columns)
trash_data = pd.read_csv(args.trash_file, sep = ' ', header = None, names = data_columns)

d1_max = pc_data.ID.max()

trash_data['ID'] = trash_data['ID']+d1_max
trash_data['class'] = 366
trash_data['class_txt'] = 'Trash'
data = pd.concat([pc_data, trash_data], axis = 0)
data['Centroid_x'] = round(data['BOX_LEFT'] + (data['BOX_W']/2),0)
data['Centroid_y'] = round(data['BOX_TOP'] - (data['BOX_H']/2),0)
data['Centroid'] = list(zip(data['Centroid_x'], data['Centroid_y']))
data.sort_values(by=['FRAME_ID', 'ID'], inplace= True)
data = [y for x, y in data.groupby('ID', as_index=False)]
data_clean = [i for i in data if len(i) > 12]

for index, value in enumerate(data_clean):
  data_clean[index]['Velocity_X'] = data_clean[index]['Centroid_x'].diff()/data_clean[index]['FRAME_ID'].diff()
  data_clean[index]['Velocity_X']  =data_clean[index]['Velocity_X'].fillna(0)
  data_clean[index]['Velocity_Y'] = data_clean[index]['Centroid_y'].diff()/data_clean[index]['FRAME_ID'].diff()
  data_clean[index]['Velocity_Y']  =data_clean[index]['Velocity_Y'].fillna(0)

flux_threshold = 2
len_stop_threshold = 12

movement_frame_min = 3

all_objects = {}
for index, frame in enumerate(data_clean):
  x = frame.iloc[0]
  y = frame.iloc[-1]
  all_objects[x.ID] = {}
  all_objects[x.ID]['Type'] = x.class_txt
  all_objects[x.ID]['First_Frame'] = x.FRAME_ID
  all_objects[x.ID]['Last_Frame'] = y.FRAME_ID
  all_objects[x.ID]['Stops'] = stop_finder(frame)  
  all_objects[x.ID]['Frame'] = frame

moving_trash = []
for i in all_objects.keys():
  if all_objects[i]['Type'] == 'Trash' and len(all_objects[i]['Stops']) > 0:
    #not sure about second part of and clause below
    if  all_objects[i]['First_Frame'] < all_objects[i]['Stops'][0][0] and all_objects[i]['Last_Frame'] > all_objects[i]['Stops'][0][1]:
      moving_trash.append(i)

people_objects = [i for i in all_objects.keys() if all_objects[i]['Type'] == 'person']

trash_objects  = [i for i in all_objects.keys() if all_objects[i]['Type'] == 'Trash']

dumping_assignments = {}
for i in moving_trash:
  #z is the frame
  z = all_objects[i]
  #l = first frame of first stop
  l = z['Frame'].loc[z['Frame']['FRAME_ID'] == z['Stops'][0][0]]
  print(l)
  dumping_assignments[i] = {}
  dumping_assignments[i]['Frame_ID'] = l['FRAME_ID'].item()
  dumping_assignments[i]['Centroid'] = l['Centroid']

for i in dumping_assignments.keys():
  point_a = dumping_assignments[i]['Centroid']
  frame_to_check = int(dumping_assignments[i]['Frame_ID'])
  min_distance = 99999999999999
  perp = 99999999999999
  for person in people_objects:
    df = all_objects[person]['Frame']
    if does_exist(frame_to_check, df)  == True:
      #print('frame',frame_to_check)
     # print('person', person)
      l = df.loc[df['FRAME_ID'] == frame_to_check]
      point_b = l['Centroid']
     # print(point_a, point_b)
      #print(type(point_a.item()), point_a.item())
      distance = np.linalg.norm(np.array(point_a.item())-np.array(point_b.item()))
      #print('dist', distance)
      if distance < min_distance:
        min_distance = distance
        perp = person
  dumping_assignments[i]['distance'] = min_distance
  dumping_assignments[i]['perp'] = perp

dumping_acts = {k: v for k, v in dumping_assignments.items() if v['perp'] != 99999999999999}

print_acts = {}
for i in dumping_acts:
  print_acts[int(i-d1_max)] = dumping_acts[i]

for i in print_acts:
  print_acts[i]['Centroid'] = str(print_acts[i]['Centroid'].item())
  print_acts[i]['Seconds'] = round(print_acts[i]['Frame_ID']/20)

x = pd.DataFrame(print_acts).T

save_dir = increment_path(Path(args.save_path), exist_ok=True)
save_dir.mkdir(parents=True, exist_ok=True)
save_path_ = str(save_dir / 'dumping.csv')

#print(save_dir)
print('saved at:', save_path_)


x.to_csv(save_path_)